X <- generateDataset3(1)[1,,]
Gap(X, 10)
X <- generateDataset2(1)[1,,]
Gap(X, 10)
Gap(X, 10)
Gap(X, 10)
Gap(X, 10)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, null_hypothesis = "gaussian", ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k, ...)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
switch(null_hypothesis,
gaussian = {
param <- rbind(apply(X, 2, mean), apply(X,2,var))
distrib <- mvrnorm
}
uniformity = {
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
param <- apply(Xtmp, 2, range)
distrib <- runif
}
uniform = {
param <- apply(X, 2, range)
distrib <- runif
})
for (b in 1:B){
Xb <- apply(param, 2, function(p) distrib(n=n, p[1], p[2]))
if (null_hypothesis == "uniformity"){
Xb <- Xb %*% t(v)
}
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k, ...)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
kopt <- which(gap[-(maxK+1)] >= gap[-1]-s[-1])[1]
if(length(kopt)==0){
kopt <- 1
}
plot(gap, main = "Gap statistics with error bars", xlab = "number of clusters", ylab = "Gap")
arrows(1:(maxK+1), gap+s, 1:(maxK+1), gap-s, angle = 90, code = 3, length = 1/8)
return(list(kopt=kopt, gap = gap, s = s))
}
Gap(X, 10)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, null_hypothesis = "gaussian", ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k, ...)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
switch(null_hypothesis,
gaussian = {
param <- rbind(apply(X, 2, mean), apply(X,2,var))
distrib <- mvrnorm
}
uniformity = {
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
param <- apply(Xtmp, 2, range)
distrib <- runif
}
uniform = {
param <- apply(X, 2, range)
distrib <- runif
})
for (b in 1:B){
Xb <- apply(param, 2, function(p) distrib(n=n, p[1], p[2]))
if (null_hypothesis == "uniformity"){
Xb <- Xb %*% t(v)
}
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k, ...)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
kopt <- which(gap[-(maxK+1)] >= gap[-1]-s[-1])[1]
if(length(kopt)==0){
kopt <- 1
}
plot(gap, main = "Gap statistics with error bars", xlab = "number of clusters", ylab = "Gap")
arrows(1:(maxK+1), gap+s, 1:(maxK+1), gap-s, angle = 90, code = 3, length = 1/8)
return(list(kopt=kopt, gap = gap, s = s))
}
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, null_hypothesis = "gaussian", ...){
print(B)
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k, ...)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
switch(null_hypothesis,
gaussian = {
param <- rbind(apply(X, 2, mean), apply(X,2,var))
distrib <- mvrnorm
}
uniformity = {
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
param <- apply(Xtmp, 2, range)
distrib <- runif
}
uniform = {
param <- apply(X, 2, range)
distrib <- runif
})
for (b in 1:B){
Xb <- apply(param, 2, function(p) distrib(n=n, p[1], p[2]))
if (null_hypothesis == "uniformity"){
Xb <- Xb %*% t(v)
}
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k, ...)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
kopt <- which(gap[-(maxK+1)] >= gap[-1]-s[-1])[1]
if(length(kopt)==0){
kopt <- 1
}
plot(gap, main = "Gap statistics with error bars", xlab = "number of clusters", ylab = "Gap")
arrows(1:(maxK+1), gap+s, 1:(maxK+1), gap-s, angle = 90, code = 3, length = 1/8)
return(list(kopt=kopt, gap = gap, s = s))
}
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, null_hypothesis = "gaussian", ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k, ...)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
switch(null_hypothesis,
gaussian = {
param <- rbind(apply(X, 2, mean), apply(X,2,var))
distrib <- mvrnorm
},
uniformity = {
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
param <- apply(Xtmp, 2, range)
distrib <- runif
},
uniform = {
param <- apply(X, 2, range)
distrib <- runif
})
for (b in 1:B){
Xb <- apply(param, 2, function(p) distrib(n=n, p[1], p[2]))
if (null_hypothesis == "uniformity"){
Xb <- Xb %*% t(v)
}
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k, ...)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
kopt <- which(gap[-(maxK+1)] >= gap[-1]-s[-1])[1]
if(length(kopt)==0){
kopt <- 1
}
plot(gap, main = "Gap statistics with error bars", xlab = "number of clusters", ylab = "Gap")
arrows(1:(maxK+1), gap+s, 1:(maxK+1), gap-s, angle = 90, code = 3, length = 1/8)
return(list(kopt=kopt, gap = gap, s = s))
}
Gap(X, 10)
Gap(X, 10, null_hypothesis = "uniform")
Gap(X, 10, null_hypothesis = "uniformity")
X <- generateDataset1(1)[1,,]
Gap(X, 10, null_hypothesis = "uniformity")
Gap(X, 10, null_hypothesis = "uniform")
Gap(X, 10)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, null_hypothesis = "gaussian", ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k, ...)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
switch(null_hypothesis,
gaussian = {
param <- rbind(apply(X, 2, mean), apply(X,2,var))
distrib <- mvrnorm
},
uniformity = {
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
param <- apply(Xtmp, 2, range)
distrib <- runif
},
uniform = {
param <- apply(X, 2, range)
distrib <- runif
})
for (b in 1:B){
Xb <- apply(param, 2, function(p) distrib(n=n, p[1], p[2]))
if (null_hypothesis == "uniformity"){
Xb <- Xb %*% t(v)
}
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k, ...)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
kopt <- which(gap[-(maxK+1)] >= gap[-1]-s[-1])[1]
if(length(kopt)==0){
kopt <- 1
}
plot(gap, main = "Gap statistics with error bars", xlab = "number of clusters", ylab = "Gap", type = "b")
arrows(1:(maxK+1), gap+s, 1:(maxK+1), gap-s, angle = 90, code = 3, length = 1/8)
return(list(kopt=kopt, gap = gap, s = s))
}
Gap(X, 10)
Gap(X, 10, B = 200)
Gap(X, 10, B = 100)
Gap(X, 10, B = 200)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, null_hypothesis = "gaussian", verbose = TRUE, ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
if(verbose){
print("Original dataset")
}
for (k in 2:(maxK+1)){
if(verbose){
print(paste("Number of cluster: ", k))
}
cluster <- clusterAlg(X, k, ...)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
switch(null_hypothesis,
gaussian = {
param <- rbind(apply(X, 2, mean), apply(X,2,var))
distrib <- mvrnorm
},
uniformity = {
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
param <- apply(Xtmp, 2, range)
distrib <- runif
},
uniform = {
param <- apply(X, 2, range)
distrib <- runif
})
for (b in 1:B){
if(verbose){
print(paste("Reference dataset number: ", b))
}
Xb <- apply(param, 2, function(p) distrib(n=n, p[1], p[2]))
if (null_hypothesis == "uniformity"){
Xb <- Xb %*% t(v)
}
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
if(verbose){
print(paste("Number of cluster: ", k))
}
cluster <- clusterAlg(Xb, k, ...)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
kopt <- which(gap[-(maxK+1)] >= gap[-1]-s[-1])[1]
if(length(kopt)==0){
kopt <- 1
}
plot(gap, main = "Gap statistics with error bars", xlab = "number of clusters", ylab = "Gap", type = "b")
arrows(1:(maxK+1), gap+s, 1:(maxK+1), gap-s, angle = 90, code = 3, length = 1/8)
return(list(kopt=kopt, gap = gap, s = s))
}
Gap(X, 10, B = 200)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, null_hypothesis = "gaussian", verbose = TRUE, ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
if(verbose){
print("Original dataset")
}
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k, ...)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
switch(null_hypothesis,
gaussian = {
param <- rbind(apply(X, 2, mean), apply(X,2,var))
distrib <- mvrnorm
},
uniformity = {
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
param <- apply(Xtmp, 2, range)
distrib <- runif
},
uniform = {
param <- apply(X, 2, range)
distrib <- runif
})
for (b in 1:B){
if(verbose){
print(paste("Reference dataset number: ", b))
}
Xb <- apply(param, 2, function(p) distrib(n=n, p[1], p[2]))
if (null_hypothesis == "uniformity"){
Xb <- Xb %*% t(v)
}
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k, ...)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
kopt <- which(gap[-(maxK+1)] >= gap[-1]-s[-1])[1]
if(length(kopt)==0){
kopt <- 1
}
plot(gap, main = "Gap statistics with error bars", xlab = "number of clusters", ylab = "Gap", type = "b")
arrows(1:(maxK+1), gap+s, 1:(maxK+1), gap-s, angle = 90, code = 3, length = 1/8)
return(list(kopt=kopt, gap = gap, s = s))
}
Gap(X, 10, B = 200)
Gap(X, 10, B = 200, myHierarchicalClustering, linkage="single")
Gap(X, 10, B = 200, myHierarchicalClustering, linkage="complete")
Gap(X, 10, B = 200, myHierarchicalClustering, linkage="average")
Gap(X, 10, B = 200, myPam)
library(Rdpack)
viewRd("man/Gap.Rd", type="html")
viewRd("man/Gap.Rd", type="html")
viewRd("man/clest.Rd", type="html")
roxygen2::roxygenise()
viewRd("man/Gap.Rd", type="html")
roxygen2::roxygenise()
viewRd("man/Gap.Rd", type="html")
a <- list()
a[["ok"]]
names(a) <- c("a","b","c")
a <- list(length = 3)
names(a) <- c("a","b","c")
names(a) <- c("d","b","c")
a <- list(type = "list",length = 3)
names(a) <- c("d","b","c")
a
a <- vector(type = "list",length = 3)
a <- vector(mode = "list",length = 3)
names(a) <- c("d","b","c")
a[c("d","c")]
a["c"] <- 0
a["d"] <- 1
a["b"] <- 2
a[c("d","c")]
a[c("d","c", "dsd")]
a
class(a["d"])
class(a[["d"]])
a[[c("d","c", "dsd")]]
a[[c("d","c")]]
a[c("d","c", "dsd")] == 0
s <- a[c("d","c", "dsd")]
s
class(s)
s[[1]]
length(s)
foo <- c(1,2,3)
names(foo) <- c("a","b","c")
foo["a"]
class(foo["a"])
foo[c("a","b")]
foo[c("a","b")][2]
class(foo[c("a","b")][2])
class(foo[c("a","b")])
d <- foo[c("a","b")]
names(foo)[d]
a <- as.character(1:10)
a
a == c("2","6","1")
dunn
cluster.stats
bootstrapInstability <- function(X, maxK, B = 50, clusterAlg = myKmean, similarity = adj.rand.index, verbose =TRUE,...){
n <- dim(X)[1]
instability <- matrix(0, maxK-1, B)
cluster1 <- cluster2 <- numeric(n)
for (b in 1:B){
if(verbose==TRUE){
print(paste("Iteration: ", b))
}
idx1 <- sample(1:n,n,replace = TRUE)
idx2 <- sample(1:n,n,replace = TRUE)
inv_idx1 <- setdiff(1:n,idx1)
inv_idx2 <- setdiff(1:n,idx2)
X1 <- X[idx1,]
X2 <- X[idx2,]
for (k in 2:maxK){
X1.cluster <- clusterAlg(X1, k,...)
X2.cluster <- clusterAlg(X2, k,...)
cluster1[idx1] <- X1.cluster$cluster
cluster2[idx2] <- X2.cluster$cluster
cluster1[inv_idx1] <- X1.cluster$predict(X[inv_idx1,])
cluster2[inv_idx2] <- X2.cluster$predict(X[inv_idx2,])
instability[k-1,b] <- 1 - similarity(cluster1, cluster2)
}
}
inst_mean <- apply(instability,1,mean)
plot(2:maxK, inst_mean, main = "Instability", xlab = "number of clusters", ylab = "instability")
return(list("inst_mean"= inst_mean, "kopt"=which.min(inst_mean)+1, "instability"=instability))
}
bootstrapInstability(X, 10)
bootstrapInstability <- function(X, maxK, B = 50, clusterAlg = myKmean, similarity = adj.rand.index, verbose =TRUE,...){
n <- dim(X)[1]
instability <- matrix(0, maxK-1, B)
cluster1 <- cluster2 <- numeric(n)
for (b in 1:B){
if(verbose==TRUE){
print(paste("Iteration: ", b))
}
idx1 <- sample(1:n,n,replace = TRUE)
idx2 <- sample(1:n,n,replace = TRUE)
inv_idx1 <- setdiff(1:n,idx1)
inv_idx2 <- setdiff(1:n,idx2)
X1 <- X[idx1,]
X2 <- X[idx2,]
for (k in 2:maxK){
X1.cluster <- clusterAlg(X1, k,...)
X2.cluster <- clusterAlg(X2, k,...)
cluster1[idx1] <- X1.cluster$cluster
cluster2[idx2] <- X2.cluster$cluster
cluster1[inv_idx1] <- X1.cluster$predict(X[inv_idx1,])
cluster2[inv_idx2] <- X2.cluster$predict(X[inv_idx2,])
instability[k-1,b] <- 1 - similarity(cluster1, cluster2)
}
}
inst_mean <- apply(instability,1,mean)
plot(2:maxK, inst_mean, main = "Instability", xlab = "number of clusters", ylab = "instability", type = "b")
return(list("inst_mean"= inst_mean, "kopt"=which.min(inst_mean)+1, "instability"=instability))
}
bootstrapInstability(X, 10)
roxygen2::roxygenise()
