if (verbose){
print(paste("Iteration: ", b))
}
for (k in 2:maxK){
#sample in proportion rho observations of the dataset
idx1 <- sort(sample(1:n, floor(rho*n), replace = F))
idx2 <- sort(sample(1:n, floor(rho*n), replace = F))
X1 <- X[idx1,]
X2 <- X[idx2,]
cl1 <- clusterAlg(X1,k,...)$cluster
cl2 <- clusterAlg(X2,k,...)$cluster
# compute the similarity on the intersection of the two subsets
inter <- intersect(idx1,idx2)
Skb[k-1,b] <- similarity(cl1[is.element(idx1, inter)], cl2[is.element(idx2, inter)])
}
}
cols = hcl.colors(maxK-1, palette = "Set 3", alpha = NULL, rev = FALSE, fixup = TRUE)
plot((1:1000/1000), ecdf(Skb[1,])((1:1000/1000)), main = "Cumulative stability distribution" ,type="l", col = cols[1], xlab = "similarity", ylab = "cumulative" )
for (k in 2:(maxK-1)){
lines((1:1000/1000), ecdf(Skb[k,])((1:1000/1000)), col= cols[k])
}
legend("topleft", as.character(2:maxK), fill=cols[1:(maxK-1)])
return(Skb)
}
hcl.pals(type = "qualitative")
ModelExplorer(X, 10)
ModelExplorer(X, 20)
hcl.pals(type = "qualitative")
ModelExplorer <- function(X, maxK, similarity=adj.rand.index, clusterAlg = myKmean, rho = 0.8, B = 100, verbose = FALSE,  ...){
n <- nrow(X)
Skb <- matrix(0, maxK-1,B)
for (b in 1:B){
if (verbose){
print(paste("Iteration: ", b))
}
for (k in 2:maxK){
#sample in proportion rho observations of the dataset
idx1 <- sort(sample(1:n, floor(rho*n), replace = F))
idx2 <- sort(sample(1:n, floor(rho*n), replace = F))
X1 <- X[idx1,]
X2 <- X[idx2,]
cl1 <- clusterAlg(X1,k,...)$cluster
cl2 <- clusterAlg(X2,k,...)$cluster
# compute the similarity on the intersection of the two subsets
inter <- intersect(idx1,idx2)
Skb[k-1,b] <- similarity(cl1[is.element(idx1, inter)], cl2[is.element(idx2, inter)])
}
}
cols = hcl.colors(maxK-1, palette = "Harmonic", alpha = NULL, rev = FALSE, fixup = TRUE)
plot((1:1000/1000), ecdf(Skb[1,])((1:1000/1000)), main = "Cumulative stability distribution" ,type="l", col = cols[1], xlab = "similarity", ylab = "cumulative" )
for (k in 2:(maxK-1)){
lines((1:1000/1000), ecdf(Skb[k,])((1:1000/1000)), col= cols[k])
}
legend("topleft", as.character(2:maxK), fill=cols[1:(maxK-1)])
return(Skb)
}
ModelExplorer(X, 20)
ModelExplorer <- function(X, maxK, similarity=adj.rand.index, clusterAlg = myKmean, rho = 0.8, B = 100, verbose = FALSE,  ...){
n <- nrow(X)
Skb <- matrix(0, maxK-1,B)
for (b in 1:B){
if (verbose){
print(paste("Iteration: ", b))
}
for (k in 2:maxK){
#sample in proportion rho observations of the dataset
idx1 <- sort(sample(1:n, floor(rho*n), replace = F))
idx2 <- sort(sample(1:n, floor(rho*n), replace = F))
X1 <- X[idx1,]
X2 <- X[idx2,]
cl1 <- clusterAlg(X1,k,...)$cluster
cl2 <- clusterAlg(X2,k,...)$cluster
# compute the similarity on the intersection of the two subsets
inter <- intersect(idx1,idx2)
Skb[k-1,b] <- similarity(cl1[is.element(idx1, inter)], cl2[is.element(idx2, inter)])
}
}
cols = hcl.colors(maxK-1, palette = "Dynamic", alpha = NULL, rev = FALSE, fixup = TRUE)
plot((1:1000/1000), ecdf(Skb[1,])((1:1000/1000)), main = "Cumulative stability distribution" ,type="l", col = cols[1], xlab = "similarity", ylab = "cumulative" )
for (k in 2:(maxK-1)){
lines((1:1000/1000), ecdf(Skb[k,])((1:1000/1000)), col= cols[k])
}
legend("topleft", as.character(2:maxK), fill=cols[1:(maxK-1)])
return(Skb)
}
ModelExplorer(X, 20)
hcl.pals(type = "qualitative")
ModelExplorer <- function(X, maxK, similarity=adj.rand.index, clusterAlg = myKmean, rho = 0.8, B = 100, verbose = FALSE,  ...){
n <- nrow(X)
Skb <- matrix(0, maxK-1,B)
for (b in 1:B){
if (verbose){
print(paste("Iteration: ", b))
}
for (k in 2:maxK){
#sample in proportion rho observations of the dataset
idx1 <- sort(sample(1:n, floor(rho*n), replace = F))
idx2 <- sort(sample(1:n, floor(rho*n), replace = F))
X1 <- X[idx1,]
X2 <- X[idx2,]
cl1 <- clusterAlg(X1,k,...)$cluster
cl2 <- clusterAlg(X2,k,...)$cluster
# compute the similarity on the intersection of the two subsets
inter <- intersect(idx1,idx2)
Skb[k-1,b] <- similarity(cl1[is.element(idx1, inter)], cl2[is.element(idx2, inter)])
}
}
cols = hcl.colors(maxK-1, palette = "Pastel 1", alpha = NULL, rev = FALSE, fixup = TRUE)
plot((1:1000/1000), ecdf(Skb[1,])((1:1000/1000)), main = "Cumulative stability distribution" ,type="l", col = cols[1], xlab = "similarity", ylab = "cumulative" )
for (k in 2:(maxK-1)){
lines((1:1000/1000), ecdf(Skb[k,])((1:1000/1000)), col= cols[k])
}
legend("topleft", as.character(2:maxK), fill=cols[1:(maxK-1)])
return(Skb)
}
ModelExplorer(X, 20)
ModelExplorer <- function(X, maxK, similarity=adj.rand.index, clusterAlg = myKmean, rho = 0.8, B = 100, verbose = FALSE,  ...){
n <- nrow(X)
Skb <- matrix(0, maxK-1,B)
for (b in 1:B){
if (verbose){
print(paste("Iteration: ", b))
}
for (k in 2:maxK){
#sample in proportion rho observations of the dataset
idx1 <- sort(sample(1:n, floor(rho*n), replace = F))
idx2 <- sort(sample(1:n, floor(rho*n), replace = F))
X1 <- X[idx1,]
X2 <- X[idx2,]
cl1 <- clusterAlg(X1,k,...)$cluster
cl2 <- clusterAlg(X2,k,...)$cluster
# compute the similarity on the intersection of the two subsets
inter <- intersect(idx1,idx2)
Skb[k-1,b] <- similarity(cl1[is.element(idx1, inter)], cl2[is.element(idx2, inter)])
}
}
cols = hcl.colors(maxK-1, palette = "Dark 3", alpha = NULL, rev = FALSE, fixup = TRUE)
plot((1:1000/1000), ecdf(Skb[1,])((1:1000/1000)), main = "Cumulative stability distribution" ,type="l", col = cols[1], xlab = "similarity", ylab = "cumulative" )
for (k in 2:(maxK-1)){
lines((1:1000/1000), ecdf(Skb[k,])((1:1000/1000)), col= cols[k])
}
legend("topleft", as.character(2:maxK), fill=cols[1:(maxK-1)])
return(Skb)
}
ModelExplorer(X, 20)
ModelExplorer <- function(X, maxK, similarity=adj.rand.index, clusterAlg = myKmean, rho = 0.8, B = 100, verbose = FALSE,  ...){
n <- nrow(X)
Skb <- matrix(0, maxK-1,B)
for (b in 1:B){
if (verbose){
print(paste("Iteration: ", b))
}
for (k in 2:maxK){
#sample in proportion rho observations of the dataset
idx1 <- sort(sample(1:n, floor(rho*n), replace = F))
idx2 <- sort(sample(1:n, floor(rho*n), replace = F))
X1 <- X[idx1,]
X2 <- X[idx2,]
cl1 <- clusterAlg(X1,k,...)$cluster
cl2 <- clusterAlg(X2,k,...)$cluster
# compute the similarity on the intersection of the two subsets
inter <- intersect(idx1,idx2)
Skb[k-1,b] <- similarity(cl1[is.element(idx1, inter)], cl2[is.element(idx2, inter)])
}
}
cols = c("blue", "green", "orange", "magenta", "cyan", "red", "yellow", "gray","black","purple","pink","brown","blue4","coral","coral2","coral4","azure","darkblue")
plot((1:1000/1000), ecdf(Skb[1,])((1:1000/1000)), main = "Cumulative stability distribution" ,type="l", col = cols[1], xlab = "similarity", ylab = "cumulative" )
for (k in 2:(maxK-1)){
lines((1:1000/1000), ecdf(Skb[k,])((1:1000/1000)), col= cols[k])
}
legend("topleft", as.character(2:maxK), fill=cols[1:(maxK-1)])
return(Skb)
}
ModelExplorer(X, 20)
ModelExplorer(X, 30)
ModelExplorer <- function(X, maxK, similarity=adj.rand.index, clusterAlg = myKmean, rho = 0.8, B = 100, verbose = FALSE,  ...){
n <- nrow(X)
Skb <- matrix(0, maxK-1,B)
for (b in 1:B){
if (verbose){
print(paste("Iteration: ", b))
}
for (k in 2:maxK){
#sample in proportion rho observations of the dataset
idx1 <- sort(sample(1:n, floor(rho*n), replace = F))
idx2 <- sort(sample(1:n, floor(rho*n), replace = F))
X1 <- X[idx1,]
X2 <- X[idx2,]
cl1 <- clusterAlg(X1,k,...)$cluster
cl2 <- clusterAlg(X2,k,...)$cluster
# compute the similarity on the intersection of the two subsets
inter <- intersect(idx1,idx2)
Skb[k-1,b] <- similarity(cl1[is.element(idx1, inter)], cl2[is.element(idx2, inter)])
}
}
if(maxK >= 20){
cols <- rainbow(maxK-1)
}
else{
cols <- c("blue", "green", "orange", "magenta", "cyan", "red", "yellow", "gray","black","purple","pink","brown","blue4","coral","coral2","coral4","azure","darkblue")
}
plot((1:1000/1000), ecdf(Skb[1,])((1:1000/1000)), main = "Cumulative stability distribution" ,type="l", col = cols[1], xlab = "similarity", ylab = "cumulative" )
for (k in 2:(maxK-1)){
lines((1:1000/1000), ecdf(Skb[k,])((1:1000/1000)), col= cols[k])
}
legend("topleft", as.character(2:maxK), fill=cols[1:(maxK-1)])
return(Skb)
}
ModelExplorer(X, 30)
ModelExplorer(X, 200)
ModelExplorer(X, 10)
ModelExplorer(X, 19)
index.DB(X, myKmean(X,2)$cluster)
index.DB(X, myKmean(X,5)$cluster)
plot(X)
lab <- c(0,2,0,2,1,2,0,2)
if(lab){print(14)}
length(table(lab))
plot3D <- function(X, label = NULL){
X <- as.matrix(X)
if(ncol(X) < 3){
stop("The number of features must be more than 2")
}
X.pca <- prcomp(X, scale=F)$x
if(is.null(label)){
scatter3d(X.pca[,1],X.pca[,2],X.pca[,3],  point.col = "blue", surface=FALSE)
}
else{
k <- length(table(label))
scatter3d(X.pca[,1],X.pca[,2],X.pca[,3], point.col =rainbow(k)[label],surface=FALSE, grid = FALSE)
}
}
plot3D(X)
normalized <- read.delim("Z:/IBE/Datasets/Microarray/Leukemia/Leukemia/normalized.txt")
View(normalized)
X <- normalized[-c(1,2)]
y <- normalized[2]
Y <- 1*(y=="ALL")+2*(y=="ALL-T")+1
plot3D(X,Y)
plot3D(X)
usethis::use_package("grDevices")
usethis::use_package("car")
usethis::use_package("carsddf")
viewRd("man/plot3D.Rd", type="html")
viewRd("man/plot3D.Rd", type="html")
a <- c(0,1)
b <- c(2,5)
c <- c(4,1)
d <- c(-1,0)
rbind(a,bc)
rbind(a,bcc)
rbind(a,b,c)
f <- rbind(a,b,c,d)
f
dist(f,f)
dist(f,t(f))
dist(f)
sqrt(20)
sum(sqrt(dist(f)))
sum(sqrt(dist(f)))/nrow(f)
aggregate(f, rep(list(cluster),d), function(x) sum(sqrt(dist(x)))/nrow(x))
d <- 2
aggregate(f, rep(list(cluster),d), function(x) sum(sqrt(dist(x)))/nrow(x))
aggregate(f, rep(list(c(1,2,2,1)),d), function(x) sum(sqrt(dist(x)))/nrow(x))
f
plot(f)
aggregate(f, rep(list(c(1,2,2,1)),d), function(x){plot(x)sum(sqrt(dist(x)))/nrow(x)})
aggregate(f, rep(list(c(1,2,2,1)),d), function(x){plot(x);sum(sqrt(dist(x)))/nrow(x)})
aggregate(f, rep(list(c(1,2,2,1)),d), function(x){print(x);sum(sqrt(dist(x)))/nrow(x)})
aggregate(f, rep(list(c(1,2,2,1)),d), function(x){print(x);sum(sqrt(dist(x)))})
dist(c(0,-1))
aggregate(f, rep(list(c(1,2,2,1)),d), function(x){dist(x)^2/length(x)})
aggregate(f, rep(list(c(1,2,2,2)),d), function(x){dist(x)^2/length(x)})
gapply(f, function(x) sum(dist(x)), c(1,2,2,1))
gapply(data.frame(f), function(x) sum(dist(x)), c(1,2,2,1))
sapply
lapply
aggregate
library(clusterSim)
clusGap
split(f, c(1,2,2,1))
f
aggregate(1:4, c(1,2,2,1), function(i) sum(dist(f[i,]))/length(i))[-1]
aggregate(1:4, list(c(1,2,2,1)), function(i) sum(dist(f[i,]))/length(i))[-1]
sqrt(2)/2
apply(f,2,mean)
f
log(c(1,2))
s <- apply(f,1,mean)
s
f
f-s
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, cluster, function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
for (b in 1:B){
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
rng <- apply(Xtmp, 2, range)
Xb <- apply(rng, 2, function(r) distrib(n=n, r[1], r[2]))
Xb <- Xb %*% t(v)
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, cluster, function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
k <- 1
while (k < maxK+1 && gap[k] < gap[k+1] - s[k+1]) {
k <- k+1
}
if(k == maxK+1){
kopt <- 1
}
else{
kopt <- k
}
k
}
plot(X)
X
Gap(X,10)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
for (b in 1:B){
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
rng <- apply(Xtmp, 2, range)
Xb <- apply(rng, 2, function(r) distrib(n=n, r[1], r[2]))
Xb <- Xb %*% t(v)
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
k <- 1
while (k < maxK+1 && gap[k] < gap[k+1] - s[k+1]) {
k <- k+1
}
if(k == maxK+1){
kopt <- 1
}
else{
kopt <- k
}
k
}
Gap(X,10)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
for (b in 1:B){
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
rng <- apply(Xtmp, 2, range)
Xb <- apply(rng, 2, function(r) runif(n=n, r[1], r[2]))
Xb <- Xb %*% t(v)
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
k <- 1
while (k < maxK+1 && gap[k] < gap[k+1] - s[k+1]) {
k <- k+1
}
if(k == maxK+1){
kopt <- 1
}
else{
kopt <- k
}
k
}
Gap(X,10)
X <- generateDataset1(1)
X <- X[1,,]
Gap(X,10)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
for (b in 1:B){
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
rng <- apply(Xtmp, 2, range)
Xb <- apply(rng, 2, function(r) runif(n=n, r[1], r[2]))
Xb <- Xb %*% t(v)
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
k <- 1
while (k < maxK+1 && gap[k] < gap[k+1] - s[k+1]) {
k <- k+1
}
if(k == maxK+1){
kopt <- 1
}
else{
kopt <- k
}
return(list(kopt=kopt, gap <- gap, s <- s))
}
Gap(X,10)
res <- Gap(X,10)
plot(res$gap)
Gap <- function(X, maxK, clusterAlg = myKmean, B = 50, ...){
X <- as.matrix(X)
W <- numeric(maxK+1)
n <- nrow(X)
W[1] <- sum(dist(X))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(X, k)$cluster
idx <- 1:n
W[k] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(X[i,]))/length(i))[-1])
}
Wb <- matrix(0, maxK+1, B)
for (b in 1:B){
Xtmp <- scale(X, center = TRUE, scale = FALSE)
v <- svd(Xtmp)$v
Xtmp <- Xtmp %*% v
rng <- apply(Xtmp, 2, range)
Xb <- apply(rng, 2, function(r) runif(n=n, r[1], r[2]))
Xb <- Xb %*% t(v)
Wb[1,b] <- sum(dist(Xb))/n
for (k in 2:(maxK+1)){
cluster <- clusterAlg(Xb, k)$cluster
idx <- 1:n
Wb[k,b] <- sum(aggregate(idx, list(cluster), function(i)sum(dist(Xb[i,]))/length(i))[-1])
}
}
lbar <- apply(log(Wb), 1, mean)
gap <- lbar - log(W)
sdk <- sqrt(apply((log(Wb)-lbar)^2, 1, mean))
s <- sdk * sqrt(1+1/B)
k <- 1
while (k < maxK+1 && gap[k] < gap[k+1] - s[k+1]) {
k <- k+1
}
if(k == maxK+1){
kopt <- 1
}
else{
kopt <- k
}
return(list(kopt=kopt, gap = gap, s = s))
}
res <- Gap(X,10)
plot(res$gap)
res$s
clusGap(X, myKmean, 10)
